[
  {
    "projectId": "c9f63009-abb1-497e-b257-2cf0d5ac16ff",
    "testId": "78a7cca9-2154-438c-88da-872f523b952b",
    "userId": "8438c458-60f1-7024-016d-8dad53a6de0e",
    "title": "TC001-root-health-check",
    "description": "Verify the root endpoint returns the correct service status and version information with a 200 HTTP status.",
    "code": "import requests\n\ndef test_root_health_check():\n    base_url = \"http://localhost:8000\"\n    url = f\"{base_url}/\"\n    try:\n        response = requests.get(url, timeout=30)\n    except requests.RequestException as e:\n        assert False, f\"Request to {url} failed: {e}\"\n    assert response.status_code == 200, f\"Expected status code 200, got {response.status_code}\"\n    try:\n        data = response.json()\n    except ValueError:\n        assert False, \"Response is not valid JSON\"\n    assert isinstance(data, dict), \"Response JSON is not an object\"\n    assert \"status\" in data and isinstance(data[\"status\"], str), \"'status' field missing or not a string\"\n    assert \"service\" in data and isinstance(data[\"service\"], str), \"'service' field missing or not a string\"\n    assert \"version\" in data and isinstance(data[\"version\"], str), \"'version' field missing or not a string\"\n\ntest_root_health_check()",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-24T20:21:56.242Z",
    "modified": "2026-01-24T20:36:09.353Z"
  },
  {
    "projectId": "c9f63009-abb1-497e-b257-2cf0d5ac16ff",
    "testId": "47a03f5f-a4d6-497b-90e9-09d9edfa5fcd",
    "userId": "8438c458-60f1-7024-016d-8dad53a6de0e",
    "title": "TC002-railway-health-check",
    "description": "Verify the /health endpoint returns the correct service status and service name with a 200 HTTP status.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:8000\"\nTIMEOUT = 30\n\ndef test_railway_health_check():\n    url = f\"{BASE_URL}/health\"\n    try:\n        response = requests.get(url, timeout=TIMEOUT)\n        response.raise_for_status()\n    except requests.RequestException as e:\n        assert False, f\"Request to {url} failed: {e}\"\n\n    assert response.status_code == 200, f\"Expected status code 200, got {response.status_code}\"\n\n    try:\n        data = response.json()\n    except ValueError:\n        assert False, \"Response is not valid JSON\"\n\n    assert isinstance(data, dict), \"Response JSON is not an object\"\n    assert \"status\" in data, \"'status' field missing in response\"\n    assert \"service\" in data, \"'service' field missing in response\"\n    assert isinstance(data[\"status\"], str), \"'status' field is not a string\"\n    assert isinstance(data[\"service\"], str), \"'service' field is not a string\"\n    assert data[\"status\"].lower() in [\"ok\", \"healthy\", \"running\", \"up\", \"active\", \"healthy\"], \\\n        f\"Unexpected status value: {data['status']}\"\n    assert len(data[\"service\"]) > 0, \"'service' field is empty\"\n\ntest_railway_health_check()",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-24T20:21:56.248Z",
    "modified": "2026-01-24T20:36:09.360Z"
  },
  {
    "projectId": "c9f63009-abb1-497e-b257-2cf0d5ac16ff",
    "testId": "299c9b1c-e3df-4c93-870d-ea6ad552af5f",
    "userId": "8438c458-60f1-7024-016d-8dad53a6de0e",
    "title": "TC003-trigger-gap-analysis-for-youtube-channel",
    "description": "Test the /analyze POST endpoint to ensure it correctly queues a gap analysis job for a YouTube channel with valid API key and request body, and returns queue position.",
    "code": "import requests\n\ndef test_trigger_gap_analysis_for_youtube_channel():\n    base_url = \"http://localhost:8000\"\n    endpoint = f\"{base_url}/analyze\"\n    api_key = \"valid_api_key_example\"  # Replace with a valid API key string in 'ApiKeyAuth' header\n    headers = {\n        \"Content-Type\": \"application/json\",\n        \"ApiKeyAuth\": api_key\n    }\n    payload = {\n        \"channel_name\": \"@examplechannel\",\n        \"access_key\": \"GAP-12345ABCDE\",\n        \"email\": \"user@example.com\",\n        \"video_count\": 5,\n        \"include_shorts\": True,\n        \"tier\": \"pro\",\n        \"language\": \"en\"\n    }\n\n    try:\n        response = requests.post(endpoint, headers=headers, json=payload, timeout=30)\n    except requests.RequestException as e:\n        assert False, f\"Request to /analyze endpoint failed: {e}\"\n\n    assert response.status_code == 200, f\"Expected status code 200, got {response.status_code}\"\n\n    try:\n        resp_json = response.json()\n    except ValueError:\n        assert False, \"Response is not valid JSON\"\n\n    # Validate expected properties in response\n    assert \"status\" in resp_json, \"'status' not in response\"\n    assert resp_json[\"status\"] == \"queued\" or resp_json[\"status\"] == \"processing\" or resp_json[\"status\"] == \"completed\", \\\n        f\"Unexpected status value: {resp_json['status']}\"\n\n    assert \"message\" in resp_json and isinstance(resp_json[\"message\"], str), \"'message' missing or not a string\"\n    assert \"access_key\" in resp_json and isinstance(resp_json[\"access_key\"], str), \"'access_key' missing or not a string\"\n    assert \"queue_position\" in resp_json and isinstance(resp_json[\"queue_position\"], int), \"'queue_position' missing or not an integer\"\n\ntest_trigger_gap_analysis_for_youtube_channel()",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-24T20:21:56.253Z",
    "modified": "2026-01-24T20:36:09.366Z"
  },
  {
    "projectId": "c9f63009-abb1-497e-b257-2cf0d5ac16ff",
    "testId": "25bc85ce-ac60-4bef-a6da-f1b8d29c7631",
    "userId": "8438c458-60f1-7024-016d-8dad53a6de0e",
    "title": "TC004-poll-analysis-status-by-access-key",
    "description": "Test the /status/{access_key} GET endpoint to verify it returns the correct analysis status including queued, processing, completed, or failed states.",
    "code": "import requests\nimport time\nimport uuid\n\nBASE_URL = \"http://localhost:8000\"\nAPI_KEY = \"test-api-key-123456\"  # Replace with valid API key if required\n\nHEADERS_AUTH = {\n    \"X-GAP-API-Key\": API_KEY\n}\n\ndef test_poll_analysis_status_by_access_key():\n    \"\"\"\n    Test the /status/{access_key} GET endpoint to verify it returns the correct analysis status\n    including queued, processing, completed, or failed states.\n    \"\"\"\n    # Generate a unique access_key for testing\n    unique_access_key = f\"GAP-{uuid.uuid4().hex[:12].upper()}\"\n\n    # First, create a new analysis to get a valid access_key\n    analyze_url = f\"{BASE_URL}/analyze\"\n    analyze_payload = {\n        \"channel_name\": \"TestChannel1234\",\n        \"access_key\": unique_access_key,\n        \"email\": \"testuser@example.com\"\n    }\n    headers = {\n        \"Content-Type\": \"application/json\",\n        # Assume API key required in header 'X-GAP-API-Key' for /analyze endpoint:\n        \"X-GAP-API-Key\": API_KEY\n    }\n\n    try:\n        # Trigger gap analysis to generate a new analysis job with an access key\n        resp = requests.post(analyze_url, json=analyze_payload, headers=headers, timeout=30)\n        assert resp.status_code == 200, f\"Analyze POST failed with status code {resp.status_code}\"\n        resp_json = resp.json()\n        assert \"access_key\" in resp_json, \"Response missing access_key\"\n        access_key = resp_json[\"access_key\"]\n\n        # Poll the /status/{access_key} endpoint to get analysis status\n        status_url = f\"{BASE_URL}/status/{access_key}\"\n        # Poll multiple times to cover different states: queued, processing, completed, or failed\n        valid_statuses = {\"queued\", \"processing\", \"completed\", \"failed\"}\n        last_status = None\n        for _ in range(5):\n            status_resp = requests.get(status_url, timeout=30)  # No auth headers as per PRD\n            assert status_resp.status_code == 200, f\"Status GET failed with status code {status_resp.status_code}\"\n            status_json = status_resp.json()\n\n            # Validate mandatory fields\n            assert \"access_key\" in status_json, \"Response missing access_key\"\n            assert \"channel_name\" in status_json, \"Response missing channel_name\"\n            assert \"status\" in status_json, \"Response missing status\"\n            assert status_json[\"access_key\"] == access_key, \"Mismatched access_key\"\n            assert status_json[\"channel_name\"] == analyze_payload[\"channel_name\"], \"Mismatched channel_name\"\n            assert status_json[\"status\"] in valid_statuses, f\"Invalid status value: {status_json['status']}\"\n\n            # Validate datetime fields if present\n            for dt_field in (\"created_at\", \"completed_at\"):\n                if dt_field in status_json and status_json[dt_field] is not None:\n                    # Basic check for ISO 8601 datetime format\n                    assert isinstance(status_json[dt_field], str) and len(status_json[dt_field]) > 0\n\n            last_status = status_json[\"status\"]\n            if last_status in {\"completed\", \"failed\"}:\n                break  # Stop polling if final state reached\n            time.sleep(1)\n    finally:\n        # There's no specific delete endpoint to clean analysis by access_key,\n        # so no resource cleanup is performed here.\n        pass\n\ntest_poll_analysis_status_by_access_key()\n",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-24T20:21:56.259Z",
    "modified": "2026-01-24T20:36:09.373Z"
  },
  {
    "projectId": "c9f63009-abb1-497e-b257-2cf0d5ac16ff",
    "testId": "6bff859f-7690-4287-9206-4c3e099bd9da",
    "userId": "8438c458-60f1-7024-016d-8dad53a6de0e",
    "title": "TC005-get-real-time-job-queue-metrics",
    "description": "Test the /queue-status GET endpoint to ensure it returns accurate real-time job queue metrics including queue length, active jobs, and max concurrent jobs.",
    "code": "import requests\n\ndef test_get_real_time_job_queue_metrics():\n    base_url = \"http://localhost:8000\"\n    url = f\"{base_url}/queue-status\"\n    timeout = 30\n\n    try:\n        response = requests.get(url, timeout=timeout)\n        response.raise_for_status()\n    except requests.RequestException as e:\n        assert False, f\"Request to /queue-status failed: {e}\"\n\n    # Validate response code and content type\n    assert response.status_code == 200, f\"Expected status code 200, got {response.status_code}\"\n    try:\n        json_data = response.json()\n    except ValueError:\n        assert False, \"Response is not valid JSON\"\n\n    # Validate required fields in response\n    for field in [\"queue_length\", \"active_jobs\", \"max_concurrent\"]:\n        assert field in json_data, f\"Missing field '{field}' in response\"\n        assert isinstance(json_data[field], int), f\"Field '{field}' should be integer, got {type(json_data[field])}\"\n\n    # Validate non-negative values (queue length and active jobs shouldn't be negative)\n    assert json_data[\"queue_length\"] >= 0, \"queue_length should be non-negative\"\n    assert json_data[\"active_jobs\"] >= 0, \"active_jobs should be non-negative\"\n    assert json_data[\"max_concurrent\"] >= 0, \"max_concurrent should be non-negative\"\n\ntest_get_real_time_job_queue_metrics()",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-24T20:21:56.264Z",
    "modified": "2026-01-24T20:36:09.380Z"
  },
  {
    "projectId": "c9f63009-abb1-497e-b257-2cf0d5ac16ff",
    "testId": "65070fd7-2b06-4a60-a33e-4952ac2bad6f",
    "userId": "8438c458-60f1-7024-016d-8dad53a6de0e",
    "title": "TC006-initiate-youtube-analytics-oauth-flow",
    "description": "Test the /api/youtube-analytics/authorize GET endpoint to verify it returns a valid authorization URL and state for OAuth flow initiation with a valid API key.",
    "code": "import requests\n\ndef test_initiate_youtube_analytics_oauth_flow():\n    base_url = \"http://localhost:8000\"\n    endpoint = \"/api/youtube-analytics/authorize\"\n    api_key = \"valid_api_key_example\"  # Replace with a valid API key for the test\n    user_id = \"test_user_123\"  # Example user_id for test\n\n    headers = {\n        \"X-GAP-API-Key\": api_key\n    }\n    params = {\n        \"user_id\": user_id\n    }\n\n    try:\n        response = requests.get(\n            f\"{base_url}{endpoint}\",\n            headers=headers,\n            params=params,\n            timeout=30\n        )\n    except requests.RequestException as e:\n        assert False, f\"HTTP request failed: {e}\"\n\n    assert response.status_code == 200, f\"Expected status code 200, got {response.status_code}\"\n    try:\n        json_data = response.json()\n    except ValueError:\n        assert False, \"Response is not valid JSON\"\n\n    assert \"status\" in json_data, \"'status' field missing in response JSON\"\n    assert json_data[\"status\"] == \"success\" or json_data[\"status\"] == \"ok\" or isinstance(json_data[\"status\"], str), \"Status field unexpected value\"\n    assert \"authorization_url\" in json_data, \"'authorization_url' field missing in response JSON\"\n    assert isinstance(json_data[\"authorization_url\"], str) and json_data[\"authorization_url\"].startswith(\"http\"), \"authorization_url is not a valid URL string\"\n    assert \"state\" in json_data, \"'state' field missing in response JSON\"\n    assert isinstance(json_data[\"state\"], str) and len(json_data[\"state\"]) > 0, \"state field is empty or not a string\"\n\ntest_initiate_youtube_analytics_oauth_flow()",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-24T20:21:56.269Z",
    "modified": "2026-01-24T20:36:09.386Z"
  },
  {
    "projectId": "c9f63009-abb1-497e-b257-2cf0d5ac16ff",
    "testId": "88999d8e-449b-496c-a7a1-79a568ba15d9",
    "userId": "8438c458-60f1-7024-016d-8dad53a6de0e",
    "title": "TC007-check-youtube-analytics-connection-status",
    "description": "Test the /api/youtube-analytics/status GET endpoint to verify it returns the correct connection status, channel ID, and token expiry for a given user ID.",
    "code": "import requests\n\ndef test_check_youtube_analytics_connection_status():\n    base_url = \"http://localhost:8000\"\n    endpoint = \"/api/youtube-analytics/status\"\n    user_id = \"test-user-123\"  # Replace with a valid user_id for a real test\n    api_key = \"test-api-key\"   # Replace with a valid API key if required\n    \n    headers = {\n        \"ApiKeyAuth\": api_key\n    }\n    \n    params = {\n        \"user_id\": user_id\n    }\n    \n    try:\n        response = requests.get(\n            f\"{base_url}{endpoint}\",\n            headers=headers,\n            params=params,\n            timeout=30\n        )\n        response.raise_for_status()\n    except requests.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n    \n    json_response = response.json()\n\n    assert \"status\" in json_response, \"Response missing 'status'\"\n    assert json_response[\"status\"] in (\"connected\", \"not_connected\"), f\"Unexpected status value: {json_response['status']}\"\n\n    # For connected status, channel_id and expires_at must be present and valid\n    if json_response[\"status\"] == \"connected\":\n        assert \"channel_id\" in json_response and isinstance(json_response[\"channel_id\"], str) and json_response[\"channel_id\"], \"Missing or invalid channel_id for connected status\"\n        assert \"expires_at\" in json_response and isinstance(json_response[\"expires_at\"], str) and json_response[\"expires_at\"], \"Missing or invalid expires_at for connected status\"\n\n    # For not_connected status, channel_id and expires_at may be absent, so no assertion needed\n\ntest_check_youtube_analytics_connection_status()",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-24T20:21:56.274Z",
    "modified": "2026-01-24T20:36:09.393Z"
  },
  {
    "projectId": "c9f63009-abb1-497e-b257-2cf0d5ac16ff",
    "testId": "468108a2-3acb-4b9d-8819-fe220103d376",
    "userId": "8438c458-60f1-7024-016d-8dad53a6de0e",
    "title": "TC008-revoke-youtube-analytics-access",
    "description": "Test the /api/youtube-analytics/disconnect DELETE endpoint to ensure it successfully revokes YouTube Analytics access for a user and returns a confirmation.",
    "code": "import requests\n\ndef test_revoke_youtube_analytics_access():\n    base_url = \"http://localhost:8000\"\n    endpoint_status = \"/api/youtube-analytics/status\"\n    endpoint_disconnect = \"/api/youtube-analytics/disconnect\"\n    headers = {}\n    timeout = 30\n\n    # Assuming API key required - set here if needed:\n    # headers[\"X-GAP-API-Key\"] = \"<YOUR_API_KEY>\"\n    # But from PRD, the security scheme for this endpoint is ApiKeyAuth presumably header based.\n    # Common pattern might be an Authorization header or custom header - since not explicit, we skip adding.\n\n    # For the test, we need a user_id. We will create a temporary connected user_id by simulating authorize + connect flow.\n    # However, no endpoint to create user or connect is exposed for test, so we assume a placeholder user_id.\n    # Since instructions say if resource ID not provided, create one and delete after.\n    # Here, no creation endpoint for user connection, so we just assume a dummy user_id which we will revoke access for.\n\n    # For robustness we first check current connection status to find a user_id with connected status.\n    # Since no user_id provided, we'll simulate user_id \"test-user-123\" for this test.\n\n    user_id = \"test-user-123\"\n\n    # Step 1: Confirm current connection status for user_id (optional)\n    try:\n        resp_status = requests.get(\n            f\"{base_url}{endpoint_status}\",\n            params={\"user_id\": user_id},\n            headers=headers,\n            timeout=timeout,\n        )\n        resp_status.raise_for_status()\n        status_json = resp_status.json()\n        # We expect status field \"connected\" or \"not_connected\"\n        assert \"status\" in status_json\n        assert status_json[\"status\"] in [\"connected\", \"not_connected\"]\n    except requests.RequestException as e:\n        # Could not get status - continue to attempt disconnect for test purpose\n        pass\n\n    # Step 2: Call DELETE to revoke YouTube Analytics access for the user\n    resp_disconnect = requests.delete(\n        f\"{base_url}{endpoint_disconnect}\",\n        params={\"user_id\": user_id},\n        headers=headers,\n        timeout=timeout,\n    )\n\n    # Validate response code 200\n    assert resp_disconnect.status_code == 200\n\n    # Validate response content - must have confirmation (description says returns confirmation)\n    # As no exact schema provided, expect json or at least success indication\n    try:\n        resp_json = resp_disconnect.json()\n        # The confirmation might be a \"status\" or \"message\" field\n        # Check at least one key exists and status is success or message non-empty\n        assert isinstance(resp_json, dict)\n        assert (\"status\" in resp_json and resp_json[\"status\"] in [\"success\", \"disconnected\", \"ok\"]) or (\"message\" in resp_json and len(str(resp_json[\"message\"])) > 0)\n    except Exception:\n        # If not JSON, accept empty or text confirmation\n        assert resp_disconnect.text is not None and len(resp_disconnect.text) > 0\n\ntest_revoke_youtube_analytics_access()",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-24T20:21:56.279Z",
    "modified": "2026-01-24T20:36:09.399Z"
  },
  {
    "projectId": "c9f63009-abb1-497e-b257-2cf0d5ac16ff",
    "testId": "34511bc2-e5d8-4a9e-ba29-f700d92a3b2c",
    "userId": "8438c458-60f1-7024-016d-8dad53a6de0e",
    "title": "TC009-check-user-subscription-tier-and-limits",
    "description": "Test the /subscription/status GET endpoint to verify it returns the correct subscription tier, status, and remaining analyses for a user email with valid API key.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:8000\"\nAPI_KEY = \"your-valid-api-key\"  # Replace with a valid API key\nTEST_EMAIL = \"testuser@example.com\"  # Replace with a valid test user email\n\ndef test_check_user_subscription_tier_and_limits():\n    url = f\"{BASE_URL}/subscription/status\"\n    headers = {\n        \"Authorization\": f\"Bearer {API_KEY}\"\n    }\n    params = {\n        \"email\": TEST_EMAIL\n    }\n\n    try:\n        response = requests.get(url, headers=headers, params=params, timeout=30)\n    except requests.RequestException as e:\n        assert False, f\"Request to /subscription/status failed: {e}\"\n\n    assert response.status_code == 200, f\"Expected status code 200, got {response.status_code}\"\n\n    try:\n        data = response.json()\n    except ValueError:\n        assert False, \"Response body is not valid JSON\"\n\n    assert isinstance(data, dict), \"Response JSON is not an object\"\n\n    # Validate required fields in response\n    assert \"tier\" in data, \"Response JSON missing 'tier'\"\n    assert isinstance(data[\"tier\"], str), \"'tier' should be a string\"\n\n    assert \"status\" in data, \"Response JSON missing 'status'\"\n    assert isinstance(data[\"status\"], str), \"'status' should be a string\"\n\n    assert \"analyses_remaining\" in data, \"Response JSON missing 'analyses_remaining'\"\n    assert isinstance(data[\"analyses_remaining\"], int), \"'analyses_remaining' should be an integer\"\n\n    # Removed strict checking of tier and status values as not explicitly defined in PRD\n\ntest_check_user_subscription_tier_and_limits()\n",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-24T20:21:56.286Z",
    "modified": "2026-01-24T20:36:09.406Z"
  },
  {
    "projectId": "c9f63009-abb1-497e-b257-2cf0d5ac16ff",
    "testId": "83647320-8f9c-49c1-84f5-d2ddaa7749ea",
    "userId": "8438c458-60f1-7024-016d-8dad53a6de0e",
    "title": "TC010-handle-stripe-subscription-webhooks",
    "description": "Test the /webhook/stripe-subscription POST endpoint to ensure it correctly processes Stripe webhook events and returns a 200 status.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:8000\"\nTIMEOUT = 30\n\ndef test_handle_stripe_subscription_webhook():\n    url = f\"{BASE_URL}/webhook/stripe-subscription\"\n    # Example Stripe webhook event payload (minimal required fields for testing)\n    payload = {\n        \"id\": \"evt_test_webhook\",\n        \"object\": \"event\",\n        \"type\": \"customer.subscription.updated\",\n        \"data\": {\n            \"object\": {\n                \"id\": \"sub_test_subscription\",\n                \"object\": \"subscription\",\n                \"status\": \"active\",\n                \"customer\": \"cus_test_customer\"\n            }\n        }\n    }\n\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n\n    try:\n        response = requests.post(url, json=payload, headers=headers, timeout=TIMEOUT)\n    except requests.RequestException as e:\n        assert False, f\"Request to {url} failed: {e}\"\n\n    assert response.status_code == 200, f\"Expected status code 200, got {response.status_code}\"\n\ntest_handle_stripe_subscription_webhook()",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-24T20:21:56.292Z",
    "modified": "2026-01-24T20:36:09.413Z"
  }
]
